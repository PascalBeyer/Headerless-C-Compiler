//
// DO NOT EDIT THIS FILE BY HAND!
//
// This file is auto-generated from `hlc.cli` using `parse_cli.c`.
// It handles parsing the command line arguments into a `cli_options` structure.
// The `main` function initiate this by calling `cli_parse_options`.
// For an explanation of what the command line parsing allows see `parse_cli.c`.
//

enum cli_option_kind{
    CLI_OPTION_none,

    CLI_OPTION_help,
    CLI_OPTION_no_stdlib,
    CLI_OPTION_no_predefines,
    CLI_OPTION_no_debug,
    CLI_OPTION_no_dynamic_base,
    CLI_OPTION_image_base,
    CLI_OPTION_show_includes,
    CLI_OPTION_subsystem,
    CLI_OPTION_out,
    CLI_OPTION_entry,
    CLI_OPTION_no_entry,
    CLI_OPTION_dll,
    CLI_OPTION_obj,
    CLI_OPTION_thread_count,
    CLI_OPTION_MP,
    CLI_OPTION_I,
    CLI_OPTION_LIBPATH,
    CLI_OPTION_D,
    CLI_OPTION_Wall,
    CLI_OPTION_Wnone,
    CLI_OPTION_W,
    CLI_OPTION_Wno,
    CLI_OPTION_incremental,
    CLI_OPTION_MF,
    CLI_OPTION_l,
    CLI_OPTION_quiet,
    CLI_OPTION_EP,
    CLI_OPTION_P,
    CLI_OPTION_Fi,
    CLI_OPTION_MD,
    CLI_OPTION_MDd,
    CLI_OPTION_MT,
    CLI_OPTION_MTd,
    CLI_OPTION_std,
    CLI_OPTION_warning_limit,
    CLI_OPTION_error_limit,
    CLI_OPTION_syntax_check,
    CLI_OPTION_dont_print_the_files,
    CLI_OPTION_seed,
    CLI_OPTION_report_warnings_in_system_includes,
    CLI_OPTION_ignore,
    CLI_OPTION_link,
    CLI_OPTION_warning,

    CLI_OPTION_count,
};

enum cli_argument_type{
    CLI_ARGUMENT_TYPE_none,
    CLI_ARGUMENT_TYPE_string,
    CLI_ARGUMENT_TYPE_u64,
    CLI_ARGUMENT_TYPE_option,
    CLI_ARGUMENT_TYPE_warning,
    CLI_ARGUMENT_TYPE_enum,
    CLI_ARGUMENT_TYPE_directory,
    CLI_ARGUMENT_TYPE_directory_list,
    CLI_ARGUMENT_TYPE_string_list,
};

struct cli_option_hash_table_entry{
    struct string canonicalized_name;
    enum cli_argument_type argument_type;
    enum cli_option_kind option_kind;
    int argument_is_optional;
} cli_option_hash_table[0x80] = {
    [110] = {{4, (u8 *)"help"}, CLI_ARGUMENT_TYPE_option, CLI_OPTION_help, 1},
    [13] = {{1, (u8 *)"h"}, CLI_ARGUMENT_TYPE_option, CLI_OPTION_help, 1},
    [100] = {{1, (u8 *)"?"}, CLI_ARGUMENT_TYPE_option, CLI_OPTION_help, 1},
    [101] = {{8, (u8 *)"nostdlib"}, CLI_ARGUMENT_TYPE_none, CLI_OPTION_no_stdlib, -1},
    [7] = {{12, (u8 *)"nopredefines"}, CLI_ARGUMENT_TYPE_none, CLI_OPTION_no_predefines, -1},
    [41] = {{7, (u8 *)"nodebug"}, CLI_ARGUMENT_TYPE_none, CLI_OPTION_no_debug, -1},
    [98] = {{13, (u8 *)"nodynamicbase"}, CLI_ARGUMENT_TYPE_none, CLI_OPTION_no_dynamic_base, -1},
    [35] = {{9, (u8 *)"imagebase"}, CLI_ARGUMENT_TYPE_u64, CLI_OPTION_image_base, 0},
    [93] = {{12, (u8 *)"showincludes"}, CLI_ARGUMENT_TYPE_none, CLI_OPTION_show_includes, -1},
    [20] = {{9, (u8 *)"subsystem"}, CLI_ARGUMENT_TYPE_enum, CLI_OPTION_subsystem, 0},
    [29] = {{3, (u8 *)"out"}, CLI_ARGUMENT_TYPE_string, CLI_OPTION_out, 0},
    [21] = {{1, (u8 *)"o"}, CLI_ARGUMENT_TYPE_string, CLI_OPTION_out, 0},
    [80] = {{2, (u8 *)"fe"}, CLI_ARGUMENT_TYPE_string, CLI_OPTION_out, 0},
    [90] = {{2, (u8 *)"fo"}, CLI_ARGUMENT_TYPE_string, CLI_OPTION_out, 0},
    [87] = {{5, (u8 *)"entry"}, CLI_ARGUMENT_TYPE_string, CLI_OPTION_entry, 0},
    [84] = {{7, (u8 *)"noentry"}, CLI_ARGUMENT_TYPE_none, CLI_OPTION_no_entry, -1},
    [33] = {{3, (u8 *)"dll"}, CLI_ARGUMENT_TYPE_none, CLI_OPTION_dll, -1},
    [22] = {{2, (u8 *)"ld"}, CLI_ARGUMENT_TYPE_none, CLI_OPTION_dll, -1},
    [25] = {{3, (u8 *)"ldd"}, CLI_ARGUMENT_TYPE_none, CLI_OPTION_dll, -1},
    [32] = {{3, (u8 *)"obj"}, CLI_ARGUMENT_TYPE_none, CLI_OPTION_obj, -1},
    [8] = {{1, (u8 *)"c"}, CLI_ARGUMENT_TYPE_none, CLI_OPTION_obj, -1},
    [70] = {{11, (u8 *)"threadcount"}, CLI_ARGUMENT_TYPE_u64, CLI_OPTION_thread_count, 0},
    [66] = {{2, (u8 *)"mp"}, CLI_ARGUMENT_TYPE_none, CLI_OPTION_MP, -1},
    [14] = {{1, (u8 *)"i"}, CLI_ARGUMENT_TYPE_directory_list, CLI_OPTION_I, 0},
    [42] = {{7, (u8 *)"libpath"}, CLI_ARGUMENT_TYPE_directory_list, CLI_OPTION_LIBPATH, 0},
    [9] = {{1, (u8 *)"d"}, CLI_ARGUMENT_TYPE_string_list, CLI_OPTION_D, 0},
    [23] = {{4, (u8 *)"wall"}, CLI_ARGUMENT_TYPE_none, CLI_OPTION_Wall, -1},
    [12] = {{5, (u8 *)"wnone"}, CLI_ARGUMENT_TYPE_none, CLI_OPTION_Wnone, -1},
    [28] = {{1, (u8 *)"w"}, CLI_ARGUMENT_TYPE_warning, CLI_OPTION_W, 0},
    [57] = {{3, (u8 *)"wno"}, CLI_ARGUMENT_TYPE_warning, CLI_OPTION_Wno, 0},
    [0] = {{2, (u8 *)"wd"}, CLI_ARGUMENT_TYPE_warning, CLI_OPTION_Wno, 0},
    [119] = {{11, (u8 *)"incremental"}, CLI_ARGUMENT_TYPE_enum, CLI_OPTION_incremental, 0},
    [56] = {{2, (u8 *)"mf"}, CLI_ARGUMENT_TYPE_string, CLI_OPTION_MF, 0},
    [17] = {{1, (u8 *)"l"}, CLI_ARGUMENT_TYPE_string_list, CLI_OPTION_l, 0},
    [15] = {{5, (u8 *)"quiet"}, CLI_ARGUMENT_TYPE_none, CLI_OPTION_quiet, -1},
    [51] = {{6, (u8 *)"nologo"}, CLI_ARGUMENT_TYPE_none, CLI_OPTION_quiet, -1},
    [58] = {{2, (u8 *)"ep"}, CLI_ARGUMENT_TYPE_none, CLI_OPTION_EP, -1},
    [24] = {{1, (u8 *)"p"}, CLI_ARGUMENT_TYPE_none, CLI_OPTION_P, -1},
    [85] = {{2, (u8 *)"fi"}, CLI_ARGUMENT_TYPE_string, CLI_OPTION_Fi, 0},
    [54] = {{2, (u8 *)"md"}, CLI_ARGUMENT_TYPE_none, CLI_OPTION_MD, -1},
    [91] = {{3, (u8 *)"mdd"}, CLI_ARGUMENT_TYPE_none, CLI_OPTION_MDd, -1},
    [71] = {{2, (u8 *)"mt"}, CLI_ARGUMENT_TYPE_none, CLI_OPTION_MT, -1},
    [106] = {{3, (u8 *)"mtd"}, CLI_ARGUMENT_TYPE_none, CLI_OPTION_MTd, -1},
    [112] = {{3, (u8 *)"std"}, CLI_ARGUMENT_TYPE_enum, CLI_OPTION_std, 0},
    [59] = {{12, (u8 *)"warninglimit"}, CLI_ARGUMENT_TYPE_none, CLI_OPTION_warning_limit, -1},
    [46] = {{10, (u8 *)"errorlimit"}, CLI_ARGUMENT_TYPE_none, CLI_OPTION_error_limit, -1},
    [74] = {{11, (u8 *)"syntaxcheck"}, CLI_ARGUMENT_TYPE_none, CLI_OPTION_syntax_check, -1},
    [114] = {{2, (u8 *)"zs"}, CLI_ARGUMENT_TYPE_none, CLI_OPTION_syntax_check, -1},
    [92] = {{17, (u8 *)"dontprintthefiles"}, CLI_ARGUMENT_TYPE_none, CLI_OPTION_dont_print_the_files, -1},
    [38] = {{4, (u8 *)"seed"}, CLI_ARGUMENT_TYPE_u64, CLI_OPTION_seed, 0},
    [125] = {{30, (u8 *)"reportwarningsinsystemincludes"}, CLI_ARGUMENT_TYPE_none, CLI_OPTION_report_warnings_in_system_includes, -1},
    [43] = {{6, (u8 *)"ignore"}, CLI_ARGUMENT_TYPE_string, CLI_OPTION_ignore, 0},
    [52] = {{4, (u8 *)"link"}, CLI_ARGUMENT_TYPE_none, CLI_OPTION_link, -1},
    [123] = {{7, (u8 *)"warning"}, CLI_ARGUMENT_TYPE_enum, CLI_OPTION_warning, 0},
    [78] = {{8, (u8 *)"warnings"}, CLI_ARGUMENT_TYPE_enum, CLI_OPTION_warning, 0},
};

enum subsystem{
    SUBSYSTEM_console         =  3, // Sets the Subsystem field to `IMAGE_SUBSYSTEM_WINDOWS_CUI`.
    SUBSYSTEM_windows         =  2, // Sets the Subsystem field to `IMAGE_SUBSYSTEM_WINDOWS_GUI`.
    SUBSYSTEM_efi_application = 10, // Sets the Subsystem field to `IMAGE_SUBSYSTEM_EFI_APPLICATION`.
};

enum incremental{
    INCREMENTAL_yes =  1, // Does nothing, we do not support incremental linking.
    INCREMENTAL_no  =  2, // This is what we do anyway :)
};

enum std{
    STD_c99 =  1, // Use c99 standard.
    STD_c11 =  2, // Use c11 standard.
    STD_c17 =  3, // Use c17 standard.
    STD_c23 =  4, // Use c23 standard.
};

enum warning{
    WARNING_missing_newline_after_backslash               =  1, // The preprocessor found a whitespace after a backslash.
    WARNING_junk_after_directive                          =  2, // The preprocessor skipped tokens after a directive in a line.
    WARNING_compile_time_overflow                         =  3, // A compile time computation caused an overflow.
    WARNING_compile_time_multiplication_by_zero           =  4, // Detected a compile-time multiplication by 0.
    WARNING_shadowing_local                               =  5, // A declaration hides a previous local declaration.
    WARNING_shadowing_global                              =  6, // A declaration hides a previous global declaration.
    WARNING_shadowing_in_same_scope                       =  7, // A declaration hides a previous declaration in the same scope.
    WARNING_type_mismatch                                 =  8, // Potentially erroneous operation between two mismatching types.
    WARNING_compile_time_truncation                       =  9, // An integer was truncated at compile type.
    WARNING_unsigned_negation                             = 10, // Applying '-' to an unsigned value results in an unsigned value.
    WARNING_unsupported_declspec                          = 11, // Unsupported or unknown __declspec(<...>) invocations are ignored.
    WARNING_ret_in_asm_block                              = 12, // A 'ret' opcode was detected in an __asm__-block.
    WARNING_does_not_declare_anything                     = 13, // Potentially malformed declaration.
    WARNING_undefined_static_if_operand                   = 14, // An undefined identifier in a #if expression gets evaluated to 0.
    WARNING_undef_on_undefined                            = 15, // Using #undef on an undefined identifier.
    WARNING_unsupported_pragma                            = 16, // Unsupported or unknown #pragma directives are ignored.
    WARNING_function_declared_but_never_defined           = 17, // A function had a declaration, but was never defined.
    WARNING_function_defined_but_unreachable              = 18, // The function is dead code and is removed from the executable.
    WARNING_unused_local_variable                         = 19, // A local variable was never referenced.
    WARNING_local_variable_only_ever_written              = 20, // A local variable that is only ever written is probably useless.
    WARNING_casting_u64_to_float                          = 21, // Casting an unsigned 64-bit value to a floating point value is slow on x64.
    WARNING_double_specifier                              = 22, // More than one of the same specifier for a declaration.
    WARNING_incorrect_format_specifier                    = 23, // Wrong argument passed to a __declspec(printlike) procedure.
    WARNING_unknown_format_specifier                      = 24, // Unknown format specifier to __declspec(printlike) procedure.
    WARNING_assignment_in_condition                       = 25, // Using an assignments in a condition is a common mistake.
    WARNING_extension_used                                = 26, // A hlc-specific extension was used. This is reported very inconsistently.
    WARNING_missing_return                                = 27, // A function forgot to return a value.
    WARNING_return_in_noreturn_function                   = 28, // A return statement inside a function declared _Noreturn.
    WARNING_function_alignment                            = 29, // Currently, specifying alignment for functions is unimplemented.
    WARNING_array_of_unknown_size_never_filled_in         = 30, // An array of unknown size without initializer (e.g: `int array[];`) that is never defined will implicitly have length 1.
    WARNING_redefining_declaration_from_extern_to_static  = 31, // First declaring a function as extern then as static is undefined behaviour.
    WARNING_inline_function_is_implicitly_external        = 32, // First declaraing a function as extern then defining it as inline will cause the resulting declaration to be 'extern inline'.
    WARNING_function_is_implicitly_dllimport              = 33, // Function was not declared with dllimport, but we could only find it as an import.
    WARNING_imported_function_is_also_defined             = 34, // Function was both found in an import library an a static library.
    WARNING_incompatible_redefinition_of_macro            = 35, // Redefined a macro with different replacement-list or arguments.
    WARNING_extraneous_semicolon                          = 36, // We found an extraneous semicolon in a structure or at global scope.
    WARNING_integer_literal_too_large_to_be_signed        = 37, // We found an integer literal that exceeds the maximum for a signed value.
    WARNING_reference_to_dllimport_inserts_stub           = 38, // A __declspec(dllimport) function was referenced in a constant initializer.
    WARNING_declaration_differs_in_attribute              = 39, // One but not all declarations of a variable is marked with an extended attribute.
    WARNING_ALTERNATENAME_type_mismatch                   = 40, // Mismatching types between the source and destination of a /ALTERNATENAME.
    WARNING_relative_include_is_treated_as_system_include = 41, // ""-Include was not found and treated as <>-Include.
    WARNING_pragma_pack_show                              = 42, // The `#praga pack(show)` directive was used.
    WARNING_octal_constant_used                           = 43, // Use an octal constant like 0420. These can be confusing and using 0o420 is recommended.
};

struct cli_options{
    
    struct string_list files; // Non-options. These are not checked, as they might contain wild-cards.
    int no_stdlib; // Don't link to 'ucrt.lib'.
    int no_predefines; // Disable all standard predefines.
    int no_debug; // Disables generation of debugging information.
    int no_dynamic_base; // Generate a non-relocatable image.
    int image_base_specified;
    u64 image_base; // Set the default image base address of the image.
    int show_includes; // Prints all file paths of included files to stdout.
    enum subsystem subsystem; // Set the 'Subsystem' field of the image optional header.
    struct string out; // Sets the name of the output files.
    struct string entry; // Explicitly set the entry point symbol.
    int no_entry; // Indicates that there is no entry point. This option implies /DLL.
    int dll; // Produce a Dynamic Link Library.
    int obj; // Produce an object file instead of an executable.
    int thread_count_specified;
    u64 thread_count; // Sets the amount of threads to be used during compilation. Default: 1
    int MP; // Sets the amount of threads to the number of processors on the system.
    struct string_list I; // Specify an additional include directory.
    struct string_list LIBPATH; // Specify an additional seach path for .lib files.
    struct string_list D; // Define a macro. Equivalent to '#define <name> <text>' or '#define <name> 1'.
    int Wall; // Enable all warnings.
    int Wnone; // Disable all warnings.
    enum incremental incremental; // Does nothing, here for MSVC cli-compatibility.
    struct string MF; // Currently ignored, is supposed to produce a .dep file?
    struct string_list l; // Link to the specified library.
    int quiet; // Print as little as necessary.
    int EP; // Print the preprocessed file to stdout.
    int P; // Print the preprocessed file to stdout.
    struct string Fi; // Sets the output file name for the preprocessed file.
    int MD; // Use `MSVCRT.lib` as run-time library. (Object Only). Define `_MT` and `_DLL`.
    int MDd; // Use `MSVCRTD.lib` as run-time library. (Object Only).  Define `_DEBUG`, `_MT` and `_DLL`.
    int MT; // Use `LIBCMT.lib` as run-time library. (Object Only). Define `_MT`.
    int MTd; // Use `LIBCMTD.lib` as run-time library. (Object Only). Define `_DEBUG` and `_MT`. This is the default.
    enum std std; // The standard to use e.g: c99, c11, c17, c23. This currently only sets __STDC__ and is otherwise ignored.
    int warning_limit; // A loose limit to the amount of warnings reported. This limit is keept on a per-thread basis.
    int error_limit; // A loose limit to the amount of errors reported. This limit is keept on a per-thread basis.
    int syntax_check; // Only check syntax. No compilation after type-checking.
    int dont_print_the_files; // Don't print the files because we are in a test suite.
    int seed_specified;
    u64 seed; // Specifies a seed used to shuffle around declarations.
    int report_warnings_in_system_includes; // Self explanatory.
    struct string ignore; // Ignores the argument.
    int link; // Ignored option, here to prevent it from interpretting it as `-l ink.lib`.
    enum warning warning; // A list of all warnings, only accessible from '-help warning'.
};

#define WARNING_none 0
#define WARNING_count 44

static u8 warning_enabled[WARNING_count]; // Later filled in for now.

struct warning_table_entry{
    struct string canonicalized_name;
    enum warning warning_kind;
} warning_table[0x40] = {
    [15] = {{28, (u8 *)"missingnewlineafterbackslash"}, WARNING_missing_newline_after_backslash},
    [46] = {{18, (u8 *)"junkafterdirective"}, WARNING_junk_after_directive},
    [17] = {{19, (u8 *)"compiletimeoverflow"}, WARNING_compile_time_overflow},
    [6] = {{31, (u8 *)"compiletimemultiplicationbyzero"}, WARNING_compile_time_multiplication_by_zero},
    [52] = {{14, (u8 *)"shadowinglocal"}, WARNING_shadowing_local},
    [26] = {{15, (u8 *)"shadowingglobal"}, WARNING_shadowing_global},
    [32] = {{20, (u8 *)"shadowinginsamescope"}, WARNING_shadowing_in_same_scope},
    [29] = {{12, (u8 *)"typemismatch"}, WARNING_type_mismatch},
    [36] = {{21, (u8 *)"compiletimetruncation"}, WARNING_compile_time_truncation},
    [55] = {{16, (u8 *)"unsignednegation"}, WARNING_unsigned_negation},
    [18] = {{19, (u8 *)"unsupporteddeclspec"}, WARNING_unsupported_declspec},
    [51] = {{13, (u8 *)"retinasmblock"}, WARNING_ret_in_asm_block},
    [53] = {{22, (u8 *)"doesnotdeclareanything"}, WARNING_does_not_declare_anything},
    [56] = {{24, (u8 *)"undefinedstaticifoperand"}, WARNING_undefined_static_if_operand},
    [38] = {{16, (u8 *)"undefonundefined"}, WARNING_undef_on_undefined},
    [39] = {{17, (u8 *)"unsupportedpragma"}, WARNING_unsupported_pragma},
    [57] = {{31, (u8 *)"functiondeclaredbutneverdefined"}, WARNING_function_declared_but_never_defined},
    [63] = {{29, (u8 *)"functiondefinedbutunreachable"}, WARNING_function_defined_but_unreachable},
    [10] = {{19, (u8 *)"unusedlocalvariable"}, WARNING_unused_local_variable},
    [23] = {{28, (u8 *)"localvariableonlyeverwritten"}, WARNING_local_variable_only_ever_written},
    [40] = {{17, (u8 *)"castingu64tofloat"}, WARNING_casting_u64_to_float},
    [27] = {{15, (u8 *)"doublespecifier"}, WARNING_double_specifier},
    [49] = {{24, (u8 *)"incorrectformatspecifier"}, WARNING_incorrect_format_specifier},
    [58] = {{22, (u8 *)"unknownformatspecifier"}, WARNING_unknown_format_specifier},
    [28] = {{21, (u8 *)"assignmentincondition"}, WARNING_assignment_in_condition},
    [19] = {{13, (u8 *)"extensionused"}, WARNING_extension_used},
    [0] = {{13, (u8 *)"missingreturn"}, WARNING_missing_return},
    [31] = {{24, (u8 *)"returninnoreturnfunction"}, WARNING_return_in_noreturn_function},
    [42] = {{17, (u8 *)"functionalignment"}, WARNING_function_alignment},
    [43] = {{31, (u8 *)"arrayofunknownsizeneverfilledin"}, WARNING_array_of_unknown_size_never_filled_in},
    [59] = {{39, (u8 *)"redefiningdeclarationfromexterntostatic"}, WARNING_redefining_declaration_from_extern_to_static},
    [41] = {{34, (u8 *)"inlinefunctionisimplicitlyexternal"}, WARNING_inline_function_is_implicitly_external},
    [62] = {{29, (u8 *)"functionisimplicitlydllimport"}, WARNING_function_is_implicitly_dllimport},
    [9] = {{29, (u8 *)"importedfunctionisalsodefined"}, WARNING_imported_function_is_also_defined},
    [3] = {{31, (u8 *)"incompatibleredefinitionofmacro"}, WARNING_incompatible_redefinition_of_macro},
    [60] = {{19, (u8 *)"extraneoussemicolon"}, WARNING_extraneous_semicolon},
    [1] = {{32, (u8 *)"integerliteraltoolargetobesigned"}, WARNING_integer_literal_too_large_to_be_signed},
    [54] = {{31, (u8 *)"referencetodllimportinsertsstub"}, WARNING_reference_to_dllimport_inserts_stub},
    [61] = {{29, (u8 *)"declarationdiffersinattribute"}, WARNING_declaration_differs_in_attribute},
    [30] = {{25, (u8 *)"alternatenametypemismatch"}, WARNING_ALTERNATENAME_type_mismatch},
    [44] = {{39, (u8 *)"relativeincludeistreatedassysteminclude"}, WARNING_relative_include_is_treated_as_system_include},
    [2] = {{14, (u8 *)"pragmapackshow"}, WARNING_pragma_pack_show},
    [4] = {{17, (u8 *)"octalconstantused"}, WARNING_octal_constant_used},
};

int cli_parse_options(struct cli_options *cli_options, struct memory_arena *arena, int argc, char *argv[]){
    
    int should_print_help = 0;
    
    for(int option_index = 1; option_index < argc; option_index++){
        char *option_cstring = argv[option_index];
        
        //
        // Allow /, -, and -- as option indicators.
        //
        int is_option = 0;
        if(*option_cstring == '/'){
            is_option = 1;
            option_cstring++;
        }else if(*option_cstring == '-'){
            is_option = 1;
            option_cstring++;
            if(*option_cstring == '-') option_cstring++;
        }else if(*option_cstring == '@'){
            //
            // @CommandFile, load the file and recursively call `cli_parse_options`.
            //
            struct os_file command_file = load_file_into_arena(option_cstring + 1, arena); // @note: This functions puts a zero-terminator.
            if(command_file.file_does_not_exist){
                print("Error: Could not load command file '%s'.\n", option_cstring + 1);
                return 0;
            }
            if(command_file.size > 2 && command_file.data[0] == 0xff && command_file.data[1] == 0xfe){
                // UTF16-LE BOM (Byte Order Mark).
                struct string as_utf8 = utf16le_to_utf8(arena, (u16 *)(command_file.data + 2), (command_file.size - 2)/2);
                command_file.size = as_utf8.size;
                command_file.data = as_utf8.data;
            }
            struct parsed_command_line parsed_command_line = windows_parse_command_line((char *)command_file.data);
            int cli_parse_options_success = cli_parse_options(cli_options, arena, parsed_command_line.argc, parsed_command_line.argv);
            if(!cli_parse_options_success) return 0;
            
            continue;
        }
        
        if(should_print_help) is_option = 1;
        
        if(!is_option){
            string_list_postfix_no_copy(&cli_options->files, arena, string_from_cstring(option_cstring));
            continue;
        }
        
        //
        // Canonicalize the option.
        //
        u8  canonicalized_option_data[0x100];
        u64 canonicalized_option_size = 0;
        char *option_argument = null;
        for(char *it = option_cstring; *it; it++){
            if(*it == '-' || *it == '_') continue;
            if(*it == '=' || *it == ':' || *it == ' '){
                if(!option_argument && *(it+1)) option_argument = it + 1;
                break;
            }
            if(canonicalized_option_size == sizeof(canonicalized_option_data)){
                print("Error: Option '%s' is too long. Command line options can be at most %lld bytes.\n", option_cstring, array_count(canonicalized_option_data));
                return 0;
            }
            canonicalized_option_data[canonicalized_option_size++] = (*it|32);
        }
        
        struct string canonicalized_option = {.data = canonicalized_option_data, .size = canonicalized_option_size};
        
        //
        // Look up the canonicalized option in the hash table.
        //
        struct cli_option_hash_table_entry *option_hash_table_entry = 0;
        u64 option_hash = string_djb2_hash(canonicalized_option);
        for(u64 index = 0; index < array_count(cli_option_hash_table); index++){
            u64 hash_index = (option_hash + index) & (array_count(cli_option_hash_table) - 1);
            if(!cli_option_hash_table[hash_index].canonicalized_name.data) break;
            if(string_match(cli_option_hash_table[hash_index].canonicalized_name, canonicalized_option)){
                option_hash_table_entry = &cli_option_hash_table[hash_index];
                break;
            }
        }
        
        //
        // If we found the hash table entry, extract the argument_type and option_kind from it.
        // Otherwise, we have to check the short options because they allow arguments without separator, like
        //     -Iinclude
        //
        enum cli_argument_type option_argument_type = CLI_ARGUMENT_TYPE_none;
        enum cli_option_kind   option_kind = CLI_OPTION_none;
        int argument_is_optional = 0;
        if(option_hash_table_entry){
            option_argument_type = option_hash_table_entry->argument_type;
            option_kind          = option_hash_table_entry->option_kind;
            argument_is_optional = option_hash_table_entry->argument_is_optional;
        }else{
            // @note: Short options need to match case-sensatively.
            struct string option = string_from_cstring(option_cstring);
            
            if(string_front_match_eat(&option, "h")){
                option_argument_type = CLI_ARGUMENT_TYPE_option;
                option_kind          = CLI_OPTION_help;
            }else if(string_front_match_eat(&option, "?")){
                option_argument_type = CLI_ARGUMENT_TYPE_option;
                option_kind          = CLI_OPTION_help;
            }else if(string_front_match_eat(&option, "out")){
                option_argument_type = CLI_ARGUMENT_TYPE_string;
                option_kind          = CLI_OPTION_out;
            }else if(string_front_match_eat(&option, "o")){
                option_argument_type = CLI_ARGUMENT_TYPE_string;
                option_kind          = CLI_OPTION_out;
            }else if(string_front_match_eat(&option, "Fe")){
                option_argument_type = CLI_ARGUMENT_TYPE_string;
                option_kind          = CLI_OPTION_out;
            }else if(string_front_match_eat(&option, "Fo")){
                option_argument_type = CLI_ARGUMENT_TYPE_string;
                option_kind          = CLI_OPTION_out;
            }else if(string_front_match_eat(&option, "I")){
                option_argument_type = CLI_ARGUMENT_TYPE_directory_list;
                option_kind          = CLI_OPTION_I;
            }else if(string_front_match_eat(&option, "D")){
                option_argument_type = CLI_ARGUMENT_TYPE_string_list;
                option_kind          = CLI_OPTION_D;
            }else if(string_front_match_eat(&option, "W")){
                option_argument_type = CLI_ARGUMENT_TYPE_warning;
                option_kind          = CLI_OPTION_W;
            }else if(string_front_match_eat(&option, "Wno")){
                option_argument_type = CLI_ARGUMENT_TYPE_warning;
                option_kind          = CLI_OPTION_Wno;
            }else if(string_front_match_eat(&option, "wd")){
                option_argument_type = CLI_ARGUMENT_TYPE_warning;
                option_kind          = CLI_OPTION_Wno;
            }else if(string_front_match_eat(&option, "MF")){
                option_argument_type = CLI_ARGUMENT_TYPE_string;
                option_kind          = CLI_OPTION_MF;
            }else if(string_front_match_eat(&option, "l")){
                option_argument_type = CLI_ARGUMENT_TYPE_string_list;
                option_kind          = CLI_OPTION_l;
            }else if(string_front_match_eat(&option, "Fi")){
                option_argument_type = CLI_ARGUMENT_TYPE_string;
                option_kind          = CLI_OPTION_Fi;
            }else if(string_front_match_eat(&option, "std")){
                option_argument_type = CLI_ARGUMENT_TYPE_enum;
                option_kind          = CLI_OPTION_std;
            }
            
            if(option_kind == CLI_OPTION_none){
                print("Warning: Unknown command-line option '%s'.\n", option_cstring);
                continue;
            }
            
            // We have eaten the option from 'option' so now its just the argument.
            option_argument = (char *)option.data;
            argument_is_optional = 0; // If we get here, there was an argument (otherwise the hash-table lookup would have worked), so we can safely set this to 0.
        }
        
        if(should_print_help && option_index + 1 >= argc) argument_is_optional = true;
        
        //
        // If the option needs an argument, make sure we have one.
        //
        if(!option_argument && (option_argument_type != CLI_ARGUMENT_TYPE_none) && !argument_is_optional){
            option_argument = argv[++option_index];
            if(!option_argument){ // @note: argv is null-pointer terminated.
                print("Error: Expected argument after command line option '%s'.\n", option_cstring);
                return 0;
            }
        }
        
        //
        // Parse the argument.
        //
        struct string argument_string = option_argument ? string_from_cstring(option_argument) : (struct string){0};
        u64 argument_as_u64 = 0;
        
        switch(option_argument_type){
            case CLI_ARGUMENT_TYPE_none: break;
            
            case CLI_ARGUMENT_TYPE_directory_list:{
                if(!path_is_directory(option_argument)){
                    print("Warning: Argument '%s' of command line option '%s' must be a directory, but it is not.\n", option_argument, option_cstring);
                    continue;
                }
            }break;
            
            case CLI_ARGUMENT_TYPE_string: break;
            case CLI_ARGUMENT_TYPE_string_list: break;
            case CLI_ARGUMENT_TYPE_enum: break;
            case CLI_ARGUMENT_TYPE_option: break;
            case CLI_ARGUMENT_TYPE_warning: break;
            case CLI_ARGUMENT_TYPE_directory:{
                if(!path_is_directory(option_argument)){
                    print("Error: Argument '%s' of command line option '%s' must be a directory, but it is not.\n", option_argument, option_cstring);
                    return 0;
                }
            }break;
            case CLI_ARGUMENT_TYPE_u64:{
                int success = true;
                argument_as_u64 = string_to_u64(argument_string, &success);
                if(!success){
                    print("Error: Could not parse argument '%.*s' of option '%s' as a u64.\n", argument_string.size, argument_string.data, option_cstring);
                    return 0;
                }
            }break;
        }
        
        // 
        // If we are supposed to print help for this option, do so!
        // 
        if(should_print_help){
            switch(option_kind){

                case CLI_OPTION_help:{
                    print("-help [option] | Display this help message or a help message for another option.\n\n");
                    os_print_string(
                            "The --help command can be used to display information on other command line arguments.\n"
                            "Usage examples:\n"
                            "    > hlc.exe --help out\n"
                            "    > hlc.exe --help subsystem:console\n"
                            "", 167);
                }break;
                case CLI_OPTION_no_stdlib:{
                    print("-no_stdlib | Don't link to 'ucrt.lib'.\n\n");
                    os_print_string(
                            "By default, the compiler adds include paths to ucrt header files and links to ucrt.lib.\n"
                            "You can disable this behaviour to ensure you are not using any standard library functions,\n"
                            "or when you want to link to a different standard library.\n"
                            "\n"
                            "> hlc.exe test.c -no_stdlib\n"
                            ">\n"
                            "> #include <stdio.h> // Error at 'include': 'stdio.h' include file not found.\n"
                            ">\n"
                            "> int main(){\n"
                            ">     printf(\"Hello, World!\\n\");\n"
                            "> }\n"
                            "", 399);
                }break;
                case CLI_OPTION_no_predefines:{
                    print("-no_predefines | Disable all standard predefines.\n\n");
                    os_print_string(
                            "TODO\n"
                            "", 5);
                }break;
                case CLI_OPTION_no_debug:{
                    print("-no_debug | Disables generation of debugging information.\n\n");
                    os_print_string(
                            "By default, the compiler generates debug information either in the form of a PDB,\n"
                            "if an image is requested, or in the for of a .debug$S and .debug$T section, if an\n"
                            "object file is requested. This option disables this behaviour.\n"
                            "", 227);
                }break;
                case CLI_OPTION_no_dynamic_base:{
                    print("-no_dynamic_base | Generate a non-relocatable image.\n\n");
                    os_print_string(
                            "This option sets the `IMAGE_FILE_RELOCS_STRIPPED` flag in the `Characteristics` \n"
                            "field of the COFF file header and skips setting the \n"
                            "`IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE` field in the `DllCharacteristics` of the\n"
                            "image optional header. Furthermore, no base relocations are produced.\n"
                            "", 285);
                }break;
                case CLI_OPTION_image_base:{
                    print("-image_base <u64> | Set the default image base address of the image.\n\n");
                    os_print_string(
                            "This option sets the `ImageBase` field of the image optional header.\n"
                            "For executables this defaults to 0x140000000 and for DLLs it defaults to 0x180000000.\n"
                            "", 155);
                }break;
                case CLI_OPTION_show_includes:{
                    print("-show_includes | Prints all file paths of included files to stdout.\n\n");
                    os_print_string(
                            "This option allows you to detect include files used by a compilation unit.\n"
                            "For example:\n"
                            "\n"
                            "> // test.c\n"
                            "> #include <stdio.h>\n"
                            "> \n"
                            "> int main(){\n"
                            ">     printf(\"Hello, World!\\n\");\n"
                            "> }\n"
                            "\n"
                            "> hlc.exe test.c /show_includes\n"
                            "> \n"
                            "> <...>\n"
                            "> \n"
                            "> C:/Program Files (x86)/Windows Kits/10/Include/10.0.20348.0/ucrt/stdio.h\n"
                            "> C:/Program Files (x86)/Windows Kits/10/Include/10.0.20348.0/ucrt/corecrt.h\n"
                            "> C:/Program Files (x86)/Microsoft Visual Studio/2022/BuildTools/VC/Tools/MSVC/14.37.32822/include/vcruntime.h\n"
                            "> C:/Program Files (x86)/Windows Kits/10/Include/10.0.20348.0/shared/sal.h\n"
                            "> C:/Program Files (x86)/Windows Kits/10/Include/10.0.20348.0/shared/concurrencysal.h\n"
                            "> C:/Program Files (x86)/Microsoft Visual Studio/2022/BuildTools/VC/Tools/MSVC/14.37.32822/include/vadefs.h\n"
                            "> C:/Program Files (x86)/Windows Kits/10/Include/10.0.20348.0/ucrt/corecrt_wstdio.h\n"
                            "> C:/Program Files (x86)/Windows Kits/10/Include/10.0.20348.0/ucrt/corecrt_stdio_config.h\n"
                            "\n"
                            "Some build tools uses this option to automatically detect which source files a compilation unit depends on.\n"
                            "", 1038);
                }break;
                case CLI_OPTION_subsystem:{
                    print("-subsystem <enum> | Set the 'Subsystem' field of the image optional header.\n\n");
                    os_print_string(
                            "This option allows you to set the 'Subsystem' field of the image optional header.\n"
                            "The default subsystem is inferred by the choice of \"main\" function.\n"
                            "If main, or wmain is defined, the default subsystem is console.\n"
                            "If WinMain or wWinMain is specified the default subsystem is windows.\n"
                            "\n"
                            "", 285);
                    if(option_argument){
                    }else{
                        os_print_string(
                                "console (3)                             | Sets the Subsystem field to `IMAGE_SUBSYSTEM_WINDOWS_CUI`.\n"
                                "windows (2)                             | Sets the Subsystem field to `IMAGE_SUBSYSTEM_WINDOWS_GUI`.\n"
                                "efi_application (10)                    | Sets the Subsystem field to `IMAGE_SUBSYSTEM_EFI_APPLICATION`.\n"
                                , 307);
                    }
                }break;
                case CLI_OPTION_out:{
                    print("-out <path> | Sets the name of the output files.\n\n");
                    os_print_string(
                            "The default output file name is derived from the first compilation unit.\n"
                            "For example, for `hlc src/test.c` the resulting files would be `test.exe` and `test.pdb`.\n"
                            "When /out specifies a directory, the resulting files are put in the directory with their \n"
                            "default name. If out does not specify a file extension, the default file extension is appended.\n"
                            "The default file extension is `.exe` for an executable, `.obj` for an object file and `.dll`\n"
                            "for a dynamic link library.\n"
                            "", 470);
                }break;
                case CLI_OPTION_entry:{
                    print("-entry <name> | Explicitly set the entry point symbol.\n\n");
                    os_print_string(
                            "TODO\n"
                            "", 5);
                }break;
                case CLI_OPTION_no_entry:{
                    print("-no_entry | Indicates that there is no entry point. This option implies /DLL.\n\n");
                    os_print_string(
                            "This option is useful for building a resource-only DLL.\n"
                            "For example:\n"
                            "\n"
                            "> hlc.exe dll.c /dll /no_entry\n"
                            ">\n"
                            "> // dll.c\n"
                            "> __declspec(dllexport) int export;\n"
                            ">\n"
                            "", 152);
                }break;
                case CLI_OPTION_dll:{
                    print("-dll | Produce a Dynamic Link Library.\n\n");
                    os_print_string(
                            "This option is used to set the output file type to be a DLL.\n"
                            "If the program is using a DllMain\n"
                            "", 95);
                }break;
                case CLI_OPTION_obj:{
                    print("-obj | Produce an object file instead of an executable.\n\n");
                    os_print_string(
                            "Using the /obj option allows you to compile in \"more classic\" c-compiler fashion.\n"
                            "\n"
                            "Example:\n"
                            "> hlc /obj main.c\n"
                            "> hlc /obj other.c\n"
                            "> link main.obj other.obj\n"
                            "> main.exe\n"
                            "", 166);
                }break;
                case CLI_OPTION_thread_count:{
                    print("-thread_count <u64> | Sets the amount of threads to be used during compilation. Default: 1\n\n");
                    os_print_string(
                            "The number of threads must be between 1 and 10 times the amount of cores your system has.\n"
                            "", 90);
                }break;
                case CLI_OPTION_MP:{
                    print("-MP | Sets the amount of threads to the number of processors on the system.\n\n");
                    os_print_string(
                            "This is the \"whatever\" throw some cores at it option.\n"
                            "", 54);
                }break;
                case CLI_OPTION_I:{
                    print("-I <dir_list> | Specify an additional include directory.\n\n");
                    os_print_string(
                            "This makes it possible to use your own headers in <>-includes.\n"
                            "", 63);
                }break;
                case CLI_OPTION_LIBPATH:{
                    print("-LIBPATH <dir_list> | Specify an additional seach path for .lib files.\n\n");
                    os_print_string(
                            "@incomplete:\n"
                            "", 13);
                }break;
                case CLI_OPTION_D:{
                    print("-D <name[=<text>]> | Define a macro. Equivalent to '#define <name> <text>' or '#define <name> 1'.\n\n");
                }break;
                case CLI_OPTION_Wall:{
                    print("-Wall | Enable all warnings.\n\n");
                    os_print_string(
                            "Enable all implemented warnings. To see a list of all warnings use `hlc.exe --help W`.\n"
                            "", 87);
                }break;
                case CLI_OPTION_Wnone:{
                    print("-Wnone | Disable all warnings.\n\n");
                    os_print_string(
                            "Disable all implemented warnings. To see a list of all warnings use `hlc.exe --help W`.\n"
                            "", 88);
                }break;
                case CLI_OPTION_W:{
                    print("-W <warning> | Enable specific warnings.\n\n");
                    os_print_string(
                            "Enables a specific warning. Warnings can be supplied either by their name, or by their number.\n"
                            "For a list of all warnings see `hlc --help warning`. For help on a specific warning, see\n"
                            "`hlc --help warning <warning>`, e.g.: `hlc --help warning type_mismatch`.\n"
                            "", 258);
                }break;
                case CLI_OPTION_Wno:{
                    print("-Wno <warning> | Disable specific warnings.\n\n");
                    os_print_string(
                            "Disables a specific warning. Warnings can be supplied either by their name, or by their number.\n"
                            "For a list of all warnings see `hlc --help warning`. For help on a specific warning, see\n"
                            "`hlc --help warning <warning>`, e.g.: `hlc --help warning type_mismatch`.\n"
                            "", 259);
                }break;
                case CLI_OPTION_incremental:{
                    print("-incremental <enum> | Does nothing, here for MSVC cli-compatibility.\n\n");
                    os_print_string(
                            "Otherwise, -INCREMENTAL:no would be interpreted as -I NCREMENTAL:no, but \"NCREMENTAL:no\" is not a directory.\n"
                            "\n"
                            "", 110);
                    if(option_argument){
                    }else{
                        os_print_string(
                                "yes (1)                                 | Does nothing, we do not support incremental linking.\n"
                                "no (2)                                  | This is what we do anyway :)\n"
                                , 166);
                    }
                }break;
                case CLI_OPTION_MF:{
                    print("-MF <file> | Currently ignored, is supposed to produce a .dep file?\n\n");
                    os_print_string(
                            "@incomplete\n"
                            "", 12);
                }break;
                case CLI_OPTION_l:{
                    print("-l <library> | Link to the specified library.\n\n");
                    os_print_string(
                            "Option is equivalent to passing `library.lib` on the command line.\n"
                            "Example:\n"
                            "> hlc main.c -luser32\n"
                            "Equivalent to\n"
                            "> hlc main.c user32.lib\n"
                            "", 136);
                }break;
                case CLI_OPTION_quiet:{
                    print("-quiet | Print as little as necessary.\n\n");
                    os_print_string(
                            "For everyone that enjoys their silence.\n"
                            "", 40);
                }break;
                case CLI_OPTION_EP:{
                    print("-EP | Print the preprocessed file to stdout.\n\n");
                    os_print_string(
                            "This is very incomplete and mostly here to make build-systems happy.\n"
                            "", 69);
                }break;
                case CLI_OPTION_P:{
                    print("-P | Print the preprocessed file to stdout.\n\n");
                    os_print_string(
                            "This is very incomplete and mostly here to make build-systems happy.\n"
                            "", 69);
                }break;
                case CLI_OPTION_Fi:{
                    print("-Fi <file> | Sets the output file name for the preprocessed file.\n\n");
                    os_print_string(
                            "Default is derived from the name of the first compilation unit.\n"
                            "E.g.: For `hlc /E test.c` it would be `test.id`.\n"
                            "", 113);
                }break;
                case CLI_OPTION_MD:{
                    print("-MD | Use `MSVCRT.lib` as run-time library. (Object Only). Define `_MT` and `_DLL`.\n\n");
                    os_print_string(
                            "See https://learn.microsoft.com/en-us/cpp/build/reference/md-mt-ld-use-run-time-library?view=msvc-170.\n"
                            "", 103);
                }break;
                case CLI_OPTION_MDd:{
                    print("-MDd | Use `MSVCRTD.lib` as run-time library. (Object Only).  Define `_DEBUG`, `_MT` and `_DLL`.\n\n");
                    os_print_string(
                            "See https://learn.microsoft.com/en-us/cpp/build/reference/md-mt-ld-use-run-time-library?view=msvc-170.\n"
                            "", 103);
                }break;
                case CLI_OPTION_MT:{
                    print("-MT | Use `LIBCMT.lib` as run-time library. (Object Only). Define `_MT`.\n\n");
                    os_print_string(
                            " \n"
                            "https://learn.microsoft.com/en-us/cpp/build/reference/md-mt-ld-use-run-time-library?view=msvc-170\n"
                            "", 100);
                }break;
                case CLI_OPTION_MTd:{
                    print("-MTd | Use `LIBCMTD.lib` as run-time library. (Object Only). Define `_DEBUG` and `_MT`. This is the default.\n\n");
                    os_print_string(
                            " \n"
                            "https://learn.microsoft.com/en-us/cpp/build/reference/md-mt-ld-use-run-time-library?view=msvc-170\n"
                            "", 100);
                }break;
                case CLI_OPTION_std:{
                    print("-std <standard> | The standard to use e.g: c99, c11, c17, c23. This currently only sets __STDC__ and is otherwise ignored.\n\n");
                    if(option_argument){
                    }else{
                        os_print_string(
                                "c99 (1)                                 | Use c99 standard.\n"
                                "c11 (2)                                 | Use c11 standard.\n"
                                "c17 (3)                                 | Use c17 standard.\n"
                                "c23 (4)                                 | Use c23 standard.\n"
                                , 240);
                    }
                }break;
                case CLI_OPTION_warning_limit:{
                    print("-warning_limit | A loose limit to the amount of warnings reported. This limit is keept on a per-thread basis.\n\n");
                }break;
                case CLI_OPTION_error_limit:{
                    print("-error_limit | A loose limit to the amount of errors reported. This limit is keept on a per-thread basis.\n\n");
                }break;
                case CLI_OPTION_syntax_check:{
                    print("-syntax_check | Only check syntax. No compilation after type-checking.\n\n");
                    os_print_string(
                            "Mostly implemented for MSVC-compatibility.\n"
                            "", 43);
                }break;
                case CLI_OPTION_dont_print_the_files:{
                    print("-dont_print_the_files | Don't print the files because we are in a test suite.\n\n");
                    os_print_string(
                            "This option is used by the test-runner for tests that only have to compile, \n"
                            "but not run.\n"
                            "", 90);
                }break;
                case CLI_OPTION_seed:{
                    print("-seed <u64> | Specifies a seed used to shuffle around declarations.\n\n");
                    os_print_string(
                            "This options exists to stress test out of order compilation.\n"
                            "If -seed 0 is used, the seed is generated by `__rdtsc()`.\n"
                            "After a bug is found, the resulting seed can be reused to reproduce the issue.\n"
                            "", 198);
                }break;
                case CLI_OPTION_report_warnings_in_system_includes:{
                    print("-report_warnings_in_system_includes | Self explanatory.\n\n");
                }break;
                case CLI_OPTION_ignore:{
                    print("-ignore <ignored> | Ignores the argument.\n\n");
                    os_print_string(
                            "This option is mostly here to add the registry key:\n"
                            "`HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\cl.exe`\n"
                            "and an option `Debugger` to `C:\\path\\to\\hlc.exe --ignore`. This will make windows redirect every call\n"
                            "to `cl.exe` to a call of `hlc.exe`.\n"
                            "", 292);
                }break;
                case CLI_OPTION_link:{
                    print("-link | Ignored option, here to prevent it from interpretting it as `-l ink.lib`.\n\n");
                }break;
                case CLI_OPTION_warning:{
                    print("-warning <enum> | A list of all warnings, only accessible from '-help warning'.\n\n");
                    if(option_argument){
                    }else{
                        os_print_string(
                                "missing_newline_after_backslash (1)     | The preprocessor found a whitespace after a backslash.\n"
                                "junk_after_directive (2)                | The preprocessor skipped tokens after a directive in a line.\n"
                                "compile_time_overflow (3)               | A compile time computation caused an overflow.\n"
                                "compile_time_multiplication_by_zero (4) | Detected a compile-time multiplication by 0.\n"
                                "shadowing_local (5)                     | A declaration hides a previous local declaration.\n"
                                "shadowing_global (6)                    | A declaration hides a previous global declaration.\n"
                                "shadowing_in_same_scope (7)             | A declaration hides a previous declaration in the same scope.\n"
                                "type_mismatch (8)                       | Potentially erroneous operation between two mismatching types.\n"
                                "compile_time_truncation (9)             | An integer was truncated at compile type.\n"
                                "unsigned_negation (10)                  | Applying '-' to an unsigned value results in an unsigned value.\n"
                                "unsupported_declspec (11)               | Unsupported or unknown __declspec(<...>) invocations are ignored.\n"
                                "ret_in_asm_block (12)                   | A 'ret' opcode was detected in an __asm__-block.\n"
                                "does_not_declare_anything (13)          | Potentially malformed declaration.\n"
                                "undefined_static_if_operand (14)        | An undefined identifier in a #if expression gets evaluated to 0.\n"
                                "undef_on_undefined (15)                 | Using #undef on an undefined identifier.\n"
                                "unsupported_pragma (16)                 | Unsupported or unknown #pragma directives are ignored.\n"
                                "function_declared_but_never_defined (17)| A function had a declaration, but was never defined.\n"
                                "function_defined_but_unreachable (18)   | The function is dead code and is removed from the executable.\n"
                                "unused_local_variable (19)              | A local variable was never referenced.\n"
                                "local_variable_only_ever_written (20)   | A local variable that is only ever written is probably useless.\n"
                                "casting_u64_to_float (21)               | Casting an unsigned 64-bit value to a floating point value is slow on x64.\n"
                                "double_specifier (22)                   | More than one of the same specifier for a declaration.\n"
                                "incorrect_format_specifier (23)         | Wrong argument passed to a __declspec(printlike) procedure.\n"
                                "unknown_format_specifier (24)           | Unknown format specifier to __declspec(printlike) procedure.\n"
                                "assignment_in_condition (25)            | Using an assignments in a condition is a common mistake.\n"
                                "extension_used (26)                     | A hlc-specific extension was used. This is reported very inconsistently.\n"
                                "missing_return (27)                     | A function forgot to return a value.\n"
                                "return_in_noreturn_function (28)        | A return statement inside a function declared _Noreturn.\n"
                                "function_alignment (29)                 | Currently, specifying alignment for functions is unimplemented.\n"
                                "array_of_unknown_size_never_filled_in (30)| An array of unknown size without initializer (e.g: `int array[];`) that is never defined will implicitly have length 1.\n"
                                "redefining_declaration_from_extern_to_static (31)| First declaring a function as extern then as static is undefined behaviour.\n"
                                "inline_function_is_implicitly_external (32)| First declaraing a function as extern then defining it as inline will cause the resulting declaration to be 'extern inline'.\n"
                                "function_is_implicitly_dllimport (33)   | Function was not declared with dllimport, but we could only find it as an import.\n"
                                "imported_function_is_also_defined (34)  | Function was both found in an import library an a static library.\n"
                                "incompatible_redefinition_of_macro (35) | Redefined a macro with different replacement-list or arguments.\n"
                                "extraneous_semicolon (36)               | We found an extraneous semicolon in a structure or at global scope.\n"
                                "integer_literal_too_large_to_be_signed (37)| We found an integer literal that exceeds the maximum for a signed value.\n"
                                "reference_to_dllimport_inserts_stub (38)| A __declspec(dllimport) function was referenced in a constant initializer.\n"
                                "declaration_differs_in_attribute (39)   | One but not all declarations of a variable is marked with an extended attribute.\n"
                                "ALTERNATENAME_type_mismatch (40)        | Mismatching types between the source and destination of a /ALTERNATENAME.\n"
                                "relative_include_is_treated_as_system_include (41)| ""-Include was not found and treated as <>-Include.\n"
                                "pragma_pack_show (42)                   | The `#praga pack(show)` directive was used.\n"
                                "octal_constant_used (43)                | Use an octal constant like 0420. These can be confusing and using 0o420 is recommended.\n"
                                , 4529);
                    }
                }break;
                invalid_default_case();
            }
            os_panic(0);
        }
        
        //
        // We are ready to parse the command line option!
        //
        switch(option_kind){
            
            case CLI_OPTION_help:{
                if(!option_argument){
                    if(option_index + 1 != argc){
                         should_print_help = 1;
                         continue;
                    }
                    
                    os_print_string(
                            "  -help [option]              | Display this help message or a help message for another option.\n"
                            "  -no_stdlib                  | Don't link to 'ucrt.lib'.\n"
                            "  -no_predefines              | Disable all standard predefines.\n"
                            "  -no_debug                   | Disables generation of debugging information.\n"
                            "  -no_dynamic_base            | Generate a non-relocatable image.\n"
                            "  -image_base <u64>           | Set the default image base address of the image.\n"
                            "  -show_includes              | Prints all file paths of included files to stdout.\n"
                            "  -subsystem <enum>           | Set the 'Subsystem' field of the image optional header.\n"
                            "  -out <path>                 | Sets the name of the output files.\n"
                            "  -entry <name>               | Explicitly set the entry point symbol.\n"
                            "  -no_entry                   | Indicates that there is no entry point. This option implies /DLL.\n"
                            "  -dll                        | Produce a Dynamic Link Library.\n"
                            "  -obj                        | Produce an object file instead of an executable.\n"
                            "  -thread_count <u64>         | Sets the amount of threads to be used during compilation. Default: 1\n"
                            "  -MP                         | Sets the amount of threads to the number of processors on the system.\n"
                            "  -I <dir_list>               | Specify an additional include directory.\n"
                            "  -LIBPATH <dir_list>         | Specify an additional seach path for .lib files.\n"
                            "  -D <name[=<text>]>          | Define a macro. Equivalent to '#define <name> <text>' or '#define <name> 1'.\n"
                            "  -Wall                       | Enable all warnings.\n"
                            "  -Wnone                      | Disable all warnings.\n"
                            "  -W <warning>                | Enable specific warnings.\n"
                            "  -Wno <warning>              | Disable specific warnings.\n"
                            "  -incremental <enum>         | Does nothing, here for MSVC cli-compatibility.\n"
                            "  -MF <file>                  | Currently ignored, is supposed to produce a .dep file?\n"
                            "  -l <library>                | Link to the specified library.\n"
                            "  -quiet                      | Print as little as necessary.\n"
                            "  -EP                         | Print the preprocessed file to stdout.\n"
                            "  -P                          | Print the preprocessed file to stdout.\n"
                            "  -Fi <file>                  | Sets the output file name for the preprocessed file.\n"
                            "  -MD                         | Use `MSVCRT.lib` as run-time library. (Object Only). Define `_MT` and `_DLL`.\n"
                            "  -MDd                        | Use `MSVCRTD.lib` as run-time library. (Object Only).  Define `_DEBUG`, `_MT` and `_DLL`.\n"
                            "  -MT                         | Use `LIBCMT.lib` as run-time library. (Object Only). Define `_MT`.\n"
                            "  -MTd                        | Use `LIBCMTD.lib` as run-time library. (Object Only). Define `_DEBUG` and `_MT`. This is the default.\n"
                            "  -std <standard>             | The standard to use e.g: c99, c11, c17, c23. This currently only sets __STDC__ and is otherwise ignored.\n"
                            "  -warning_limit              | A loose limit to the amount of warnings reported. This limit is keept on a per-thread basis.\n"
                            "  -error_limit                | A loose limit to the amount of errors reported. This limit is keept on a per-thread basis.\n"
                            "  -syntax_check               | Only check syntax. No compilation after type-checking.\n"
                    , 3141);
                }else{
                    //
                    //@HACK: We want to handle --help=argument exactly as we handle --help argument.
                    //       Hence, I reset the argument array here.
                    //
                    should_print_help = 1;
                    static char *new_argv[2];
                    new_argv[0] = option_argument;
                    option_index = -1;
                    argv = new_argv;
                    argc = 1;
                    continue;
                }
                os_panic(0);
            }break;

            case CLI_OPTION_no_stdlib: cli_options->no_stdlib = 1; break;
            case CLI_OPTION_no_predefines: cli_options->no_predefines = 1; break;
            case CLI_OPTION_no_debug: cli_options->no_debug = 1; break;
            case CLI_OPTION_no_dynamic_base: cli_options->no_dynamic_base = 1; break;
            
            case CLI_OPTION_image_base:{
                cli_options->image_base_specified = 1;
                cli_options->image_base = argument_as_u64;
            }break;
            case CLI_OPTION_show_includes: cli_options->show_includes = 1; break;
            
            case CLI_OPTION_subsystem:{
                if(string_match_case_insensitive(argument_string, string("console"))){
                    cli_options->subsystem = SUBSYSTEM_console;
                }else if(string_match_case_insensitive(argument_string, string("windows"))){
                    cli_options->subsystem = SUBSYSTEM_windows;
                }else if(string_match_case_insensitive(argument_string, string("efi_application"))){
                    cli_options->subsystem = SUBSYSTEM_efi_application;
                }else{
                    print("Error: Unhandled value '%.*s' for command line option '%s'.\n", argument_string.size, argument_string.data, option_cstring);
                    return 0;
                }
            }break;
            
            case CLI_OPTION_out:{
                cli_options->out = argument_string;
            }break;
            
            case CLI_OPTION_entry:{
                cli_options->entry = argument_string;
            }break;
            case CLI_OPTION_no_entry: cli_options->no_entry = 1; break;
            case CLI_OPTION_dll: cli_options->dll = 1; break;
            case CLI_OPTION_obj: cli_options->obj = 1; break;
            
            case CLI_OPTION_thread_count:{
                cli_options->thread_count_specified = 1;
                cli_options->thread_count = argument_as_u64;
            }break;
            case CLI_OPTION_MP: cli_options->MP = 1; break;
            
            case CLI_OPTION_I:{
                string_list_postfix(&cli_options->I, arena, argument_string);
            }break;
            
            case CLI_OPTION_LIBPATH:{
                string_list_postfix(&cli_options->LIBPATH, arena, argument_string);
            }break;
            
            case CLI_OPTION_D:{
                string_list_postfix(&cli_options->D, arena, argument_string);
            }break;
            case CLI_OPTION_Wall: memset(warning_enabled, 1, sizeof(warning_enabled)); break;
            case CLI_OPTION_Wnone: memset(warning_enabled, 0, sizeof(warning_enabled)); break;
            
            case CLI_OPTION_W:{
                int is_number = 1;
                u64 warning_value = string_to_u64(argument_string, &is_number);
                if(is_number){
                    if(warning_value >= WARNING_count){
                        print("Warning: Unhandled warning value %lld.\n", warning_value);
                    }else{
                        warning_enabled[warning_value] = 1;
                    }
                    break;
                }
                //
                // Canonicalize the Warning-Name.
                //
                u8  canonicalized_warning_data[0x100];
                u64 canonicalized_warning_size = 0;
                for(smm index = 0; index < argument_string.size; index++){
                    char c = argument_string.data[index];
                    if(c == '-' || c == '_') continue;
                    
                    if(canonicalized_warning_size == sizeof(canonicalized_warning_data)){
                        print("Error: Option '%.*s' is too long. Command line warnings can be at most %lld bytes.\n", argument_string.size, argument_string.data, array_count(canonicalized_warning_data));
                        return 0;
                    }
                    canonicalized_warning_data[canonicalized_warning_size++] = (c|32);
                }
                
                struct string canonicalized_warning = {.data = canonicalized_warning_data, .size = canonicalized_warning_size};
                
                struct warning_table_entry *warning_entry = null;
                u64 warning_hash = string_djb2_hash(canonicalized_warning);
                for(u64 index = 0; index < array_count(warning_table); index++){
                    u64 hash_index = (warning_hash + index) & (array_count(warning_table) - 1);
                    if(!warning_table[hash_index].canonicalized_name.data) break;
                    if(string_match(warning_table[hash_index].canonicalized_name, canonicalized_warning)){
                        warning_entry = &warning_table[hash_index];
                        break;
                    }
                }
                
                if(!warning_entry){
                    print("Warning: Unhandled warning value '%.*s'.\n", argument_string.size, argument_string.data);
                }else{
                    warning_enabled[warning_entry->warning_kind] = 1;
                }
            }break;
            
            case CLI_OPTION_Wno:{
                int is_number = 1;
                u64 warning_value = string_to_u64(argument_string, &is_number);
                if(is_number){
                    if(warning_value >= WARNING_count){
                        print("Warning: Unhandled warning value %lld.\n", warning_value);
                    }else{
                        warning_enabled[warning_value] = 0;
                    }
                    break;
                }
                //
                // Canonicalize the Warning-Name.
                //
                u8  canonicalized_warning_data[0x100];
                u64 canonicalized_warning_size = 0;
                for(smm index = 0; index < argument_string.size; index++){
                    char c = argument_string.data[index];
                    if(c == '-' || c == '_') continue;
                    
                    if(canonicalized_warning_size == sizeof(canonicalized_warning_data)){
                        print("Error: Option '%.*s' is too long. Command line warnings can be at most %lld bytes.\n", argument_string.size, argument_string.data, array_count(canonicalized_warning_data));
                        return 0;
                    }
                    canonicalized_warning_data[canonicalized_warning_size++] = (c|32);
                }
                
                struct string canonicalized_warning = {.data = canonicalized_warning_data, .size = canonicalized_warning_size};
                
                struct warning_table_entry *warning_entry = null;
                u64 warning_hash = string_djb2_hash(canonicalized_warning);
                for(u64 index = 0; index < array_count(warning_table); index++){
                    u64 hash_index = (warning_hash + index) & (array_count(warning_table) - 1);
                    if(!warning_table[hash_index].canonicalized_name.data) break;
                    if(string_match(warning_table[hash_index].canonicalized_name, canonicalized_warning)){
                        warning_entry = &warning_table[hash_index];
                        break;
                    }
                }
                
                if(!warning_entry){
                    print("Warning: Unhandled warning value '%.*s'.\n", argument_string.size, argument_string.data);
                }else{
                    warning_enabled[warning_entry->warning_kind] = 0;
                }
            }break;
            
            case CLI_OPTION_incremental:{
                if(string_match_case_insensitive(argument_string, string("yes"))){
                    cli_options->incremental = INCREMENTAL_yes;
                }else if(string_match_case_insensitive(argument_string, string("no"))){
                    cli_options->incremental = INCREMENTAL_no;
                }else{
                    print("Error: Unhandled value '%.*s' for command line option '%s'.\n", argument_string.size, argument_string.data, option_cstring);
                    return 0;
                }
            }break;
            
            case CLI_OPTION_MF:{
                cli_options->MF = argument_string;
            }break;
            
            case CLI_OPTION_l:{
                string_list_postfix(&cli_options->l, arena, argument_string);
            }break;
            case CLI_OPTION_quiet: cli_options->quiet = 1; break;
            case CLI_OPTION_EP: cli_options->EP = 1; break;
            case CLI_OPTION_P: cli_options->P = 1; break;
            
            case CLI_OPTION_Fi:{
                cli_options->Fi = argument_string;
            }break;
            case CLI_OPTION_MD: cli_options->MD = 1; break;
            case CLI_OPTION_MDd: cli_options->MDd = 1; break;
            case CLI_OPTION_MT: cli_options->MT = 1; break;
            case CLI_OPTION_MTd: cli_options->MTd = 1; break;
            
            case CLI_OPTION_std:{
                if(string_match_case_insensitive(argument_string, string("c99"))){
                    cli_options->std = STD_c99;
                }else if(string_match_case_insensitive(argument_string, string("c11"))){
                    cli_options->std = STD_c11;
                }else if(string_match_case_insensitive(argument_string, string("c17"))){
                    cli_options->std = STD_c17;
                }else if(string_match_case_insensitive(argument_string, string("c23"))){
                    cli_options->std = STD_c23;
                }else{
                    print("Error: Unhandled value '%.*s' for command line option '%s'.\n", argument_string.size, argument_string.data, option_cstring);
                    return 0;
                }
            }break;
            case CLI_OPTION_warning_limit: cli_options->warning_limit = 1; break;
            case CLI_OPTION_error_limit: cli_options->error_limit = 1; break;
            case CLI_OPTION_syntax_check: cli_options->syntax_check = 1; break;
            case CLI_OPTION_dont_print_the_files: cli_options->dont_print_the_files = 1; break;
            
            case CLI_OPTION_seed:{
                cli_options->seed_specified = 1;
                cli_options->seed = argument_as_u64;
            }break;
            case CLI_OPTION_report_warnings_in_system_includes: cli_options->report_warnings_in_system_includes = 1; break;
            
            case CLI_OPTION_ignore:{
                cli_options->ignore = argument_string;
            }break;
            case CLI_OPTION_link: cli_options->link = 1; break;
            
            case CLI_OPTION_count:
            case CLI_OPTION_none:
            case CLI_OPTION_warning:
                invalid_code_path;
        }
    }

    return 1;
}
