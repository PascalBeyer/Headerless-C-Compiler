// compile -stdlib
// run

#include <uchar.h>
#include <string.h>

#define print(...) (printf(__VA_ARGS__), fflush(0))
#define assert(a) if(!(a)) return -1

void string_eat_front(char **string, int amount){
    (*string) += amount;
}

unsigned utf8_read_codepoint(char **string){
    
    unsigned char leading_character = (*string)[0];
    string_eat_front(string, 1);
    
    // return if the character is in the ascii range
    if((leading_character & 0b10000000) != 0b10000000) return leading_character;
    
    // figure out the size based on the leading zeroes
    unsigned size = 0; 
    for(unsigned bit = 0b01000000; bit; bit >>= 1){
        if(!(bit & leading_character)) break;
        size += 1;
    }
    
    // leading_character has 'size + 1' leading ones and then one zero. 
    unsigned char leading_character_bits = 8 - (size + 1);
    unsigned char leading_character_mask = (1u << leading_character_bits) - 1;
    
    unsigned leading_character_shift = 1u << (6 * size);
    
    //
    // The leading character consists of the highest bits.
    // The last byte consists of the lowest bits.
    //
    unsigned codepoint = leading_character_shift * (leading_character & leading_character_mask);
    
    for(unsigned shift = leading_character_shift >> 6, index = 0; index < size; index++, shift >>= 6){
        unsigned char character = (*string)[index];
        
        if((character & 0b11000000) != 0b10000000){
            return (unsigned)-1;
        }
        
        codepoint |=  shift * (character & 0b00111111);
    }
    
    
    
    string_eat_front(string, size);
    return codepoint;
}

// #define GENERATE_CHECK

#ifdef GENERATE_CHECK
#include <stdio.h>
#else
char *c_runes_check[] = {
   (char[]){0xe1, 0x9a, 0xa0, 0xe1, 0x9b, 0x87, 0xe1, 0x9a, 0xbb, 0xe1, 0x9b, 0xab, 0xe1, 0x9b, 0x92, 0xe1, 0x9b, 0xa6, 0xe1, 0x9a, 0xa6, 0xe1, 0x9b, 0xab, 0xe1, 0x9a, 0xa0, 0xe1, 0x9a, 0xb1, 0xe1, 0x9a, 0xa9, 0xe1, 0x9a, 0xa0, 0xe1, 0x9a, 0xa2, 0xe1, 0x9a, 0xb1, 0xe1, 0x9b, 0xab, 0xe1, 0x9a, 0xa0, 0xe1, 0x9b, 0x81, 0xe1, 0x9a, 0xb1, 0xe1, 0x9a, 0xaa, 0xe1, 0x9b, 0xab, 0xe1, 0x9a, 0xb7, 0xe1, 0x9b, 0x96, 0xe1, 0x9a, 0xbb, 0xe1, 0x9a, 0xb9, 0xe1, 0x9b, 0xa6, 0xe1, 0x9b, 0x9a, 0xe1, 0x9a, 0xb3, 0xe1, 0x9a, 0xa2, 0xe1, 0x9b, 0x97, 0x00},
   (char[]){0xe1, 0x9b, 0x8b, 0xe1, 0x9a, 0xb3, 0xe1, 0x9b, 0x96, 0xe1, 0x9a, 0xaa, 0xe1, 0x9b, 0x9a, 0xe1, 0x9b, 0xab, 0xe1, 0x9a, 0xa6, 0xe1, 0x9b, 0x96, 0xe1, 0x9a, 0xaa, 0xe1, 0x9a, 0xbb, 0xe1, 0x9b, 0xab, 0xe1, 0x9b, 0x97, 0xe1, 0x9a, 0xaa, 0xe1, 0x9a, 0xbe, 0xe1, 0x9a, 0xbe, 0xe1, 0x9a, 0xaa, 0xe1, 0x9b, 0xab, 0xe1, 0x9a, 0xb7, 0xe1, 0x9b, 0x96, 0xe1, 0x9a, 0xbb, 0xe1, 0x9a, 0xb9, 0xe1, 0x9b, 0xa6, 0xe1, 0x9b, 0x9a, 0xe1, 0x9a, 0xb3, 0xe1, 0x9b, 0xab, 0xe1, 0x9b, 0x97, 0xe1, 0x9b, 0x81, 0xe1, 0x9a, 0xb3, 0xe1, 0x9b, 0x9a, 0xe1, 0x9a, 0xa2, 0xe1, 0x9a, 0xbe, 0xe1, 0x9b, 0xab, 0xe1, 0x9a, 0xbb, 0xe1, 0x9b, 0xa6, 0xe1, 0x9b, 0x8f, 0xe1, 0x9b, 0xab, 0xe1, 0x9b, 0x9e, 0xe1, 0x9a, 0xab, 0xe1, 0x9b, 0x9a, 0xe1, 0x9a, 0xaa, 0xe1, 0x9a, 0xbe, 0x00},
   (char[]){0xe1, 0x9a, 0xb7, 0xe1, 0x9b, 0x81, 0xe1, 0x9a, 0xa0, 0xe1, 0x9b, 0xab, 0xe1, 0x9a, 0xbb, 0xe1, 0x9b, 0x96, 0xe1, 0x9b, 0xab, 0xe1, 0x9a, 0xb9, 0xe1, 0x9b, 0x81, 0xe1, 0x9b, 0x9a, 0xe1, 0x9b, 0x96, 0xe1, 0x9b, 0xab, 0xe1, 0x9a, 0xa0, 0xe1, 0x9a, 0xa9, 0xe1, 0x9a, 0xb1, 0xe1, 0x9b, 0xab, 0xe1, 0x9b, 0x9e, 0xe1, 0x9a, 0xb1, 0xe1, 0x9b, 0x81, 0xe1, 0x9a, 0xbb, 0xe1, 0x9b, 0x8f, 0xe1, 0x9a, 0xbe, 0xe1, 0x9b, 0x96, 0xe1, 0x9b, 0xab, 0xe1, 0x9b, 0x9e, 0xe1, 0x9a, 0xa9, 0xe1, 0x9b, 0x97, 0xe1, 0x9b, 0x96, 0xe1, 0x9b, 0x8b, 0xe1, 0x9b, 0xab, 0xe1, 0x9a, 0xbb, 0xe1, 0x9b, 0x9a, 0xe1, 0x9b, 0x87, 0xe1, 0x9b, 0x8f, 0xe1, 0x9a, 0xaa, 0xe1, 0x9a, 0xbe, 0xe1, 0x9b, 0xac, 0x00},
};

wchar_t *w_runes_check[] = {
   (wchar_t []){0x16a0, 0x16c7, 0x16bb, 0x16eb, 0x16d2, 0x16e6, 0x16a6, 0x16eb, 0x16a0, 0x16b1, 0x16a9, 0x16a0, 0x16a2, 0x16b1, 0x16eb, 0x16a0, 0x16c1, 0x16b1, 0x16aa, 0x16eb, 0x16b7, 0x16d6, 0x16bb, 0x16b9, 0x16e6, 0x16da, 0x16b3, 0x16a2, 0x16d7, 0x0000},
   (wchar_t []){0x16cb, 0x16b3, 0x16d6, 0x16aa, 0x16da, 0x16eb, 0x16a6, 0x16d6, 0x16aa, 0x16bb, 0x16eb, 0x16d7, 0x16aa, 0x16be, 0x16be, 0x16aa, 0x16eb, 0x16b7, 0x16d6, 0x16bb, 0x16b9, 0x16e6, 0x16da, 0x16b3, 0x16eb, 0x16d7, 0x16c1, 0x16b3, 0x16da, 0x16a2, 0x16be, 0x16eb, 0x16bb, 0x16e6, 0x16cf, 0x16eb, 0x16de, 0x16ab, 0x16da, 0x16aa, 0x16be, 0x0000},
   (wchar_t []){0x16b7, 0x16c1, 0x16a0, 0x16eb, 0x16bb, 0x16d6, 0x16eb, 0x16b9, 0x16c1, 0x16da, 0x16d6, 0x16eb, 0x16a0, 0x16a9, 0x16b1, 0x16eb, 0x16de, 0x16b1, 0x16c1, 0x16bb, 0x16cf, 0x16be, 0x16d6, 0x16eb, 0x16de, 0x16a9, 0x16d7, 0x16d6, 0x16cb, 0x16eb, 0x16bb, 0x16da, 0x16c7, 0x16cf, 0x16aa, 0x16be, 0x16ec, 0x0000},
};

char32_t *u_runes_check[] = {
   (char32_t[]){0x000016a0, 0x000016c7, 0x000016bb, 0x000016eb, 0x000016d2, 0x000016e6, 0x000016a6, 0x000016eb, 0x000016a0, 0x000016b1, 0x000016a9, 0x000016a0, 0x000016a2, 0x000016b1, 0x000016eb, 0x000016a0, 0x000016c1, 0x000016b1, 0x000016aa, 0x000016eb, 0x000016b7, 0x000016d6, 0x000016bb, 0x000016b9, 0x000016e6, 0x000016da, 0x000016b3, 0x000016a2, 0x000016d7, 0x000000},
   (char32_t[]){0x000016cb, 0x000016b3, 0x000016d6, 0x000016aa, 0x000016da, 0x000016eb, 0x000016a6, 0x000016d6, 0x000016aa, 0x000016bb, 0x000016eb, 0x000016d7, 0x000016aa, 0x000016be, 0x000016be, 0x000016aa, 0x000016eb, 0x000016b7, 0x000016d6, 0x000016bb, 0x000016b9, 0x000016e6, 0x000016da, 0x000016b3, 0x000016eb, 0x000016d7, 0x000016c1, 0x000016b3, 0x000016da, 0x000016a2, 0x000016be, 0x000016eb, 0x000016bb, 0x000016e6, 0x000016cf, 0x000016eb, 0x000016de, 0x000016ab, 0x000016da, 0x000016aa, 0x000016be, 0x000000},
   (char32_t[]){0x000016b7, 0x000016c1, 0x000016a0, 0x000016eb, 0x000016bb, 0x000016d6, 0x000016eb, 0x000016b9, 0x000016c1, 0x000016da, 0x000016d6, 0x000016eb, 0x000016a0, 0x000016a9, 0x000016b1, 0x000016eb, 0x000016de, 0x000016b1, 0x000016c1, 0x000016bb, 0x000016cf, 0x000016be, 0x000016d6, 0x000016eb, 0x000016de, 0x000016a9, 0x000016d7, 0x000016d6, 0x000016cb, 0x000016eb, 0x000016bb, 0x000016da, 0x000016c7, 0x000016cf, 0x000016aa, 0x000016be, 0x000016ec, 0x000000},
};
#endif

int main(){
	char *c_runes[] ={
		"ᚠᛇᚻ᛫ᛒᛦᚦ᛫ᚠᚱᚩᚠᚢᚱ᛫ᚠᛁᚱᚪ᛫ᚷᛖᚻᚹᛦᛚᚳᚢᛗ",
		"ᛋᚳᛖᚪᛚ᛫ᚦᛖᚪᚻ᛫ᛗᚪᚾᚾᚪ᛫ᚷᛖᚻᚹᛦᛚᚳ᛫ᛗᛁᚳᛚᚢᚾ᛫ᚻᛦᛏ᛫ᛞᚫᛚᚪᚾ",
		"ᚷᛁᚠ᛫ᚻᛖ᛫ᚹᛁᛚᛖ᛫ᚠᚩᚱ᛫ᛞᚱᛁᚻᛏᚾᛖ᛫ᛞᚩᛗᛖᛋ᛫ᚻᛚᛇᛏᚪᚾ᛬",
	};
	
	#ifdef GENERATE_CHECK
	print("char *c_runes_check[] = {\n");
	for(int string_index = 0; string_index < sizeof(c_runes)/sizeof(*c_runes); string_index++){
		print("   (char[]){");
		for(char *c_rune = c_runes[string_index]; *c_rune; c_rune++){
			print("0x%.2x, ", (unsigned char)*c_rune);
		}
		print("0x00},\n");
	}
	print("};\n");
	#else
		for(int string_index = 0; string_index < sizeof(c_runes)/sizeof(*c_runes); string_index++){
			int length = strlen(c_runes[string_index]);
			assert(memcmp(c_runes[string_index], c_runes_check[string_index], length + 1) == 0);
		}
		#endif

	wchar_t *w_runes[] ={
		L"ᚠᛇᚻ᛫ᛒᛦᚦ᛫ᚠᚱᚩᚠᚢᚱ᛫ᚠᛁᚱᚪ᛫ᚷᛖᚻᚹᛦᛚᚳᚢᛗ",
		L"ᛋᚳᛖᚪᛚ᛫ᚦᛖᚪᚻ᛫ᛗᚪᚾᚾᚪ᛫ᚷᛖᚻᚹᛦᛚᚳ᛫ᛗᛁᚳᛚᚢᚾ᛫ᚻᛦᛏ᛫ᛞᚫᛚᚪᚾ",
		L"ᚷᛁᚠ᛫ᚻᛖ᛫ᚹᛁᛚᛖ᛫ᚠᚩᚱ᛫ᛞᚱᛁᚻᛏᚾᛖ᛫ᛞᚩᛗᛖᛋ᛫ᚻᛚᛇᛏᚪᚾ᛬",
	};
	
	#ifdef GENERATE_CHECK
	print("\nwchar_t *w_runes_check[] = {\n");
	for(int string_index = 0; string_index < sizeof(w_runes)/sizeof(*w_runes); string_index++){
		print("   (wchar_t []){");
		for(wchar_t *w_rune = w_runes[string_index]; *w_rune; w_rune++){
			print("0x%.4x, ", (unsigned short)*w_rune);
		}
		print("0x0000},\n");
	}
	print("};\n");
	#else
		for(int string_index = 0; string_index < sizeof(w_runes)/sizeof(*w_runes); string_index++){
			int length = wcslen(w_runes[string_index]);
			assert(memcmp(w_runes[string_index], w_runes_check[string_index], sizeof(wchar_t) *(length + 1)) == 0);
		}
#endif	

	char32_t *u_runes[] ={
		U"ᚠᛇᚻ᛫ᛒᛦᚦ᛫ᚠᚱᚩᚠᚢᚱ᛫ᚠᛁᚱᚪ᛫ᚷᛖᚻᚹᛦᛚᚳᚢᛗ",
		U"ᛋᚳᛖᚪᛚ᛫ᚦᛖᚪᚻ᛫ᛗᚪᚾᚾᚪ᛫ᚷᛖᚻᚹᛦᛚᚳ᛫ᛗᛁᚳᛚᚢᚾ᛫ᚻᛦᛏ᛫ᛞᚫᛚᚪᚾ",
		U"ᚷᛁᚠ᛫ᚻᛖ᛫ᚹᛁᛚᛖ᛫ᚠᚩᚱ᛫ᛞᚱᛁᚻᛏᚾᛖ᛫ᛞᚩᛗᛖᛋ᛫ᚻᛚᛇᛏᚪᚾ᛬",
	};
	
	#ifdef GENERATE_CHECK
	print("\nchar32_t *u_runes_check[] = {\n");
	for(int string_index = 0; string_index < sizeof(u_runes)/sizeof(*u_runes); string_index++){
		print("   (char32_t[]){");
		for(char32_t *u_rune = u_runes[string_index]; *u_rune; u_rune++){
			print("0x%.8x, ", (unsigned)*u_rune);
		}
		print("0x000000},\n");
	}
	print("};\n");
	#else
	
	for(int string_index = 0; string_index < sizeof(u_runes)/sizeof(*u_runes); string_index++){
			int length = 0;
			for(char32_t *c = u_runes[string_index]; *c; c++) length++; 
			
			assert(memcmp(u_runes[string_index], u_runes_check[string_index], sizeof(char32_t) *(length + 1)) == 0);
		}
		#endif	
	
	for(int string_index = 0; string_index < 3; string_index++){
		char32_t *u_rune = u_runes[string_index];
		wchar_t  *w_rune = w_runes[string_index];
		char     *c_rune = c_runes[string_index];
		
		for(char32_t *rune = u_rune; *rune; rune++){
			unsigned codepoint = utf8_read_codepoint(&c_rune);
			assert(codepoint == *rune);
			
			assert(!(0xD800 <= codepoint && codepoint < 0xE000)); // invalid utf-16 range
			
			if(codepoint < 0x10000){
				assert(codepoint == *w_rune);
				w_rune += 1;
			}else{
				wchar_t w1 = w_rune[0];
				wchar_t w2 = w_rune[1];
				w_rune += 2;
				
				assert((w1 & 0xF800) == 0xD800);
				assert((w2 & 0xF800) == 0xDD00);
				
				assert(codepoint == (0x10000 + ((w1 & 0x1111111111) << 10 | (w2 & 0x1111111111))));
			}
		}
	}		
}


int memcmp(void *_string1, void *_string2, size_t amount){
    
    if(amount == 0) return 0;
    
    char *string1 = _string1;
    char *string2 = _string2;
    
    while(--amount && *string1 == *string2){
        string1 += 1;
        string2 += 1;
    }
    
    return *(unsigned char *)string1 - *(unsigned char *)string2;
}

